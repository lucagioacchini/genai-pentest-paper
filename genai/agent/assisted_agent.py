from .base_agent import BaseAgent
from ..working_memory import ReActChain
from ..procedures import (SummaryProcedure,
                          ThoughtProcedure,
                          ActionProcedure,
                          TaskEndedProcedure,
                          TaskReportProcedure)
from ..prompts import (SUMMARY_TEMPLATE,
                       THOUGHT_TEMPLATE,
                       ACTION_TEMPLATE,
                       TASK_ENDED_TEMPLATE,
                       TASK_REPORT_TEMPLATE)
from termcolor import cprint
import json


class AssistedAgent(BaseAgent):
    """A human-assisted autonomous agent that can reason and act based on 
    observations and a given task.

    This class extends the BaseAgent class and implements the step method to perform
    autonomous reasoning and action selection.

    Args:
        memory_handler (list): The scratchpads of each sub-task.
        prompt_template (str): A template string for formatting the agent's prompt.
        llm (LLMClient): An instance of the LLM client for generating responses.
        working_memory (ReActScratchpad): An instance to manage the agent's working memory.
        tools (list): A list of tool functions available to the agent.
        logpath (str, optional): Path to save logs. Defaults to None.

    Attributes:
        prompt_template (str): The template for formatting the agent's prompt.
        working_memory (ReActScratchpad): The agent's working memory.
        llm (LLMClient): The LLM client used by the agent.
        tools (dict): A dictionary of available tools, keyed by their names.
        logpath (str): Path for saving logs.
        task (str): The current task assigned to the agent.
        prompt (str): The formatted prompt for the current task.
        last_step (ReActChain): The most recent step in the agent's reasoning chain.
        start (bool): Flag indicating if this is the start of a new task.
        step_limit (int): Step budget for the current sub-task
        current_task_step (int): Counter for steps in the current sub-task.

    Methods:
        reset(task): Resets the agent's state for a new task.
        update_memory(observation): Updates the agent's working memory with a new observation.
        write_logs(fpath): Writes the agent's memory logs to a file.
        agent_finish(observation): Finalizes the agent's task with a final observation.
        step(observation): Performs a single step in the agent's reasoning process.
    """

    def __init__(self, **data):
        super().__init__(**data)
        self.memory_handler = []
        self.logs = {'tasks': [], 'reports': []}
        self.step_limit = 7

    def reset(self):
        """Resets the agent's state for a new task.

        Args:
            task (str): The new task to be assigned to the agent.
        """
        # Ask the human for the current sub-task
        self.task = input('Provide your task:\n')
        self.task = f'{self.task}'
        self.prompt = self.prompt_template.format(input=self.task)
        self.current_task_step = 0

        # Create a new scratchpad for the subtask
        new_scratchpad = self.working_memory.__class__()

        # Populate the memory handler
        self.memory_handler.append(new_scratchpad)

        # Set the working memory as the last element in memory handler
        self.working_memory = self.memory_handler[-1]

    def write_logs(self, fpath: str):
        """Writes the agent's memory logs to a JSON file.

        Args:
            fpath (str): The file path where the logs should be written.
        """
        logs = []

        # Retrieve scratchpad of past sub-tasks
        for working_memory in self.memory_handler:
            logs = logs + working_memory.to_log()
        # Save the logs
        obj = {
            'steps': logs,
            'metadata': self.logs
        }
        with open(f'{fpath}.json', 'w') as file:
            file.write(json.dumps(obj))

    def step(self, observation: str):
        """Performs a single step in the agent's reasoning and action process.

        This method implements the core logic of the assisted agent, including:
        1. Updating the working memory with the new observation
        2. Checking if the current sub-task has ended
        3. Generating a summary of the current state
        4. Producing a thought about the next action
        5. Selecting and formatting the next action

        The method also handles task reporting and logging when a sub-task ends.

        Args:
            observation (str): The current observation to process.

        Returns:
            Union[ReActChain, _type_]: 
                Either the updated last step of the agent's reasoning chain,
                or a task report if the sub-task has ended.
        """
        # Update Working Memory
        self.current_task_step += 1
        self.update_memory(observation)

        # Task Ended procedure: decide if the current sub-task is ended
        task_ended = False
        if self.current_task_step > 1:
            checkpoint = TaskEndedProcedure(self.llm, TASK_ENDED_TEMPLATE)
            llm_out = checkpoint.run(
                self.task,
                self.working_memory.to_text()
            )
            task_ended = llm_out.task_ended

        # If the current sub-task is ended, produce a summary
        if task_ended or self.current_task_step == self.step_limit:
            # Task Report procedure: inform the user on what the agent did up to now
            task_report_procedure = TaskReportProcedure(
                self.llm, TASK_REPORT_TEMPLATE)
            llm_out = task_report_procedure.run(
                self.working_memory.to_text()
            )

            # Manage metadata
            self.logs['tasks'].append(self.task)
            self.logs['reports'].append(llm_out.task_report)

            # Write the logs
            self.write_logs(self.logpath)
            self.current_task_step = 0

            return llm_out

        # Get scratchpad and prompt
        self.scratchpad = self.working_memory.to_messages()
        instructions = self.prompt_template.format(input=self.task)

        # Summary reasoning procedure: produce a task-oriented procedure of
        # the aget scratchpad
        summary_procedure = SummaryProcedure(self.llm, SUMMARY_TEMPLATE)
        llm_out = summary_procedure.run(instructions, self.scratchpad)
        summary = f'{llm_out.summary}\n' +\
                  f'Identified target: {llm_out.identified_target}\n' +\
                  f'Task reminder: {llm_out.task_reminder}'
        cprint(f'Summary: {summary}', color='yellow')

        # Thought reasoning procedure: produce a thought on the next action
        thought_procedure = ThoughtProcedure(self.llm, THOUGHT_TEMPLATE)
        llm_out = thought_procedure.run(summary, self.last_step)
        thought = llm_out.thought
        cprint(f'Thought: {thought}', color='cyan')

        # Action reasoning procedure: provide the next action
        action_procedure = ActionProcedure(self.llm, ACTION_TEMPLATE)
        llm_out = action_procedure.run(
            summary, self.last_step, thought, self.tools)
        action = llm_out.action
        tool = action.__class__.__name__
        cprint(f'Action: {tool}({action})', color='magenta')

        # Format the last reasoning chain
        self.last_step = ReActChain.format(summary, thought, action)

        return self.last_step
